{"ast":null,"code":"import React, { useState, useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from 'swr';\nimport { IS_REACT_LEGACY, useIsomorphicLayoutEffect, withMiddleware, serialize, mergeObjects, getTimestamp, UNDEFINED } from 'swr/_internal';\nconst startTransition = IS_REACT_LEGACY ? cb => {\n  cb();\n} : React.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n */\nconst useStateWithDeps = state => {\n  const [, rerender] = useState({});\n  const unmountedRef = useRef(false);\n  const stateRef = useRef(state);\n  // If a state property (data, error, or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n  const stateDependenciesRef = useRef({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\n  * @param payload To change stateRef, pass the values explicitly to setState:\n  * @example\n  * ```js\n  * setState({\n  *   isValidating: false\n  *   data: newData // set data to newData\n  *   error: undefined // set error to undefined\n  * })\n  *\n  * setState({\n  *   isValidating: false\n  *   data: undefined // set data to undefined\n  *   error: err // set error to err\n  * })\n  * ```\n  */\n  const setState = useCallback(payload => {\n    let shouldRerender = false;\n    const currentState = stateRef.current;\n    for (const _ in payload) {\n      const k = _;\n      // If the property has changed, update the state and mark rerender as\n      // needed.\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k];\n        // If the property is accessed by the component, a rerender should be\n        // triggered.\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    unmountedRef.current = false;\n    return () => {\n      unmountedRef.current = true;\n    };\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\nconst mutation = () => (key, fetcher, config = {}) => {\n  const {\n    mutate\n  } = useSWRConfig();\n  const keyRef = useRef(key);\n  const fetcherRef = useRef(fetcher);\n  const configRef = useRef(config);\n  // Ditch all mutation results that happened earlier than this timestamp.\n  const ditchMutationsUntilRef = useRef(0);\n  const [stateRef, stateDependencies, setState] = useStateWithDeps({\n    data: UNDEFINED,\n    error: UNDEFINED,\n    isMutating: false\n  });\n  const currentState = stateRef.current;\n  const trigger = useCallback(async (arg, opts) => {\n    const [serializedKey, resolvedKey] = serialize(keyRef.current);\n    if (!fetcherRef.current) {\n      throw new Error('Can’t trigger the mutation: missing fetcher.');\n    }\n    if (!serializedKey) {\n      throw new Error('Can’t trigger the mutation: missing key.');\n    }\n    // Disable cache population by default.\n    const options = mergeObjects(mergeObjects({\n      populateCache: false,\n      throwOnError: true\n    }, configRef.current), opts);\n    // Trigger a mutation, and also track the timestamp. Any mutation that happened\n    // earlier this timestamp should be ignored.\n    const mutationStartedAt = getTimestamp();\n    ditchMutationsUntilRef.current = mutationStartedAt;\n    setState({\n      isMutating: true\n    });\n    try {\n      const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n        arg\n      }),\n      // We must throw the error here so we can catch and update the states.\n      mergeObjects(options, {\n        throwOnError: true\n      }));\n      // If it's reset after the mutation, we don't broadcast any state change.\n      if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n        var _options_onSuccess, _options;\n        startTransition(() => setState({\n          data,\n          isMutating: false,\n          error: undefined\n        }));\n        (_options_onSuccess = (_options = options).onSuccess) == null ? void 0 : _options_onSuccess.call(_options, data, serializedKey, options);\n      }\n      return data;\n    } catch (error) {\n      // If it's reset after the mutation, we don't broadcast any state change\n      // or throw because it's discarded.\n      if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n        var _options_onError, _options1;\n        startTransition(() => setState({\n          error: error,\n          isMutating: false\n        }));\n        (_options_onError = (_options1 = options).onError) == null ? void 0 : _options_onError.call(_options1, error, serializedKey, options);\n        if (options.throwOnError) {\n          throw error;\n        }\n      }\n    }\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  const reset = useCallback(() => {\n    ditchMutationsUntilRef.current = getTimestamp();\n    setState({\n      data: UNDEFINED,\n      error: UNDEFINED,\n      isMutating: false\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    keyRef.current = key;\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n  });\n  // We don't return `mutate` here as it can be pretty confusing (e.g. people\n  // calling `mutate` but they actually mean `trigger`).\n  // And also, `mutate` relies on the useSWR hook to exist too.\n  return {\n    trigger,\n    reset,\n    get data() {\n      stateDependencies.data = true;\n      return currentState.data;\n    },\n    get error() {\n      stateDependencies.error = true;\n      return currentState.error;\n    },\n    get isMutating() {\n      stateDependencies.isMutating = true;\n      return currentState.isMutating;\n    }\n  };\n};\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */\nconst useSWRMutation = withMiddleware(useSWR, mutation);\nexport { useSWRMutation as default };","map":{"version":3,"names":["React","useState","useRef","useCallback","useSWR","useSWRConfig","IS_REACT_LEGACY","useIsomorphicLayoutEffect","withMiddleware","serialize","mergeObjects","getTimestamp","UNDEFINED","startTransition","cb","useStateWithDeps","state","rerender","unmountedRef","stateRef","stateDependenciesRef","data","error","isValidating","setState","payload","shouldRerender","currentState","current","_","k","mutation","key","fetcher","config","mutate","keyRef","fetcherRef","configRef","ditchMutationsUntilRef","stateDependencies","isMutating","trigger","arg","opts","serializedKey","resolvedKey","Error","options","populateCache","throwOnError","mutationStartedAt","_options_onSuccess","_options","undefined","onSuccess","call","_options_onError","_options1","onError","reset","useSWRMutation","default"],"sources":["C:/Users/abish/projects/musings-project/musings-frontend/node_modules/swr/mutation/dist/index.mjs"],"sourcesContent":["import React, { useState, useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from 'swr';\nimport { IS_REACT_LEGACY, useIsomorphicLayoutEffect, withMiddleware, serialize, mergeObjects, getTimestamp, UNDEFINED } from 'swr/_internal';\n\nconst startTransition = IS_REACT_LEGACY ? (cb)=>{\n    cb();\n} : React.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n */ const useStateWithDeps = (state)=>{\n    const [, rerender] = useState({});\n    const unmountedRef = useRef(false);\n    const stateRef = useRef(state);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = useCallback((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const _ in payload){\n            const k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n\nconst mutation = ()=>(key, fetcher, config = {})=>{\n        const { mutate } = useSWRConfig();\n        const keyRef = useRef(key);\n        const fetcherRef = useRef(fetcher);\n        const configRef = useRef(config);\n        // Ditch all mutation results that happened earlier than this timestamp.\n        const ditchMutationsUntilRef = useRef(0);\n        const [stateRef, stateDependencies, setState] = useStateWithDeps({\n            data: UNDEFINED,\n            error: UNDEFINED,\n            isMutating: false\n        });\n        const currentState = stateRef.current;\n        const trigger = useCallback(async (arg, opts)=>{\n            const [serializedKey, resolvedKey] = serialize(keyRef.current);\n            if (!fetcherRef.current) {\n                throw new Error('Can’t trigger the mutation: missing fetcher.');\n            }\n            if (!serializedKey) {\n                throw new Error('Can’t trigger the mutation: missing key.');\n            }\n            // Disable cache population by default.\n            const options = mergeObjects(mergeObjects({\n                populateCache: false,\n                throwOnError: true\n            }, configRef.current), opts);\n            // Trigger a mutation, and also track the timestamp. Any mutation that happened\n            // earlier this timestamp should be ignored.\n            const mutationStartedAt = getTimestamp();\n            ditchMutationsUntilRef.current = mutationStartedAt;\n            setState({\n                isMutating: true\n            });\n            try {\n                const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n                    arg\n                }), // We must throw the error here so we can catch and update the states.\n                mergeObjects(options, {\n                    throwOnError: true\n                }));\n                // If it's reset after the mutation, we don't broadcast any state change.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    var _options_onSuccess, _options;\n                    startTransition(()=>setState({\n                            data,\n                            isMutating: false,\n                            error: undefined\n                        }));\n                    (_options_onSuccess = (_options = options).onSuccess) == null ? void 0 : _options_onSuccess.call(_options, data, serializedKey, options);\n                }\n                return data;\n            } catch (error) {\n                // If it's reset after the mutation, we don't broadcast any state change\n                // or throw because it's discarded.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    var _options_onError, _options1;\n                    startTransition(()=>setState({\n                            error: error,\n                            isMutating: false\n                        }));\n                    (_options_onError = (_options1 = options).onError) == null ? void 0 : _options_onError.call(_options1, error, serializedKey, options);\n                    if (options.throwOnError) {\n                        throw error;\n                    }\n                }\n            }\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        []);\n        const reset = useCallback(()=>{\n            ditchMutationsUntilRef.current = getTimestamp();\n            setState({\n                data: UNDEFINED,\n                error: UNDEFINED,\n                isMutating: false\n            });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n        useIsomorphicLayoutEffect(()=>{\n            keyRef.current = key;\n            fetcherRef.current = fetcher;\n            configRef.current = config;\n        });\n        // We don't return `mutate` here as it can be pretty confusing (e.g. people\n        // calling `mutate` but they actually mean `trigger`).\n        // And also, `mutate` relies on the useSWR hook to exist too.\n        return {\n            trigger,\n            reset,\n            get data () {\n                stateDependencies.data = true;\n                return currentState.data;\n            },\n            get error () {\n                stateDependencies.error = true;\n                return currentState.error;\n            },\n            get isMutating () {\n                stateDependencies.isMutating = true;\n                return currentState.isMutating;\n            }\n        };\n    };\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */ const useSWRMutation = withMiddleware(useSWR, mutation);\n\nexport { useSWRMutation as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}